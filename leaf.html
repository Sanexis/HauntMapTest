<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>–ó–æ–Ω—ã –∏ –¥–æ–º–∏–∫–∏ ‚Äî Leaflet + Leaflet.draw</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .leaflet-container { background: #eef2f5; }
    .toolbar { position: absolute; top: 12px; left: 12px; z-index: 1000; background: rgba(255,255,255,0.95); border: 1px solid #ddd; border-radius: 10px; padding: 10px; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; box-shadow: 0 2px 10px rgba(0,0,0,0.08); }
    .toolbar .row { display: flex; gap: 10px; align-items: center; margin-top: 8px; }
    .btn { cursor: pointer; border: 1px solid #bbb; background: #fff; padding: 6px 10px; border-radius: 8px; }
    .btn:hover { background: #f5f5f5; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="toolbar">
    <div>–¢–∏–ø –∑–æ–Ω—ã:</div>
    <label><input type="radio" name="zoneType" value="bear" checked> üêª –∫–æ—Ä–∏—á–Ω–µ–≤–∞—è</label>
    <label><input type="radio" name="zoneType" value="wolf"> üê∫ —Å–µ—Ä–∞—è</label>
    <label><input type="radio" name="zoneType" value="fox"> ü¶ä –æ—Ä–∞–Ω–∂–µ–≤–∞—è</label>
    <div class="row">
      <button id="btn-draw" class="btn">–ù–∞—á–∞—Ç—å —Ä–∏—Å–æ–≤–∞–Ω–∏–µ</button>
      <button id="btn-edit" class="btn">–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å</button>
      <button id="btn-finish-edit" class="btn">–ì–æ—Ç–æ–≤–æ</button>
      <button id="btn-house" class="btn">–†–µ–∂–∏–º –¥–æ–º–∏–∫–æ–≤</button>
      <button id="btn-delete" class="btn">–£–¥–∞–ª–µ–Ω–∏–µ</button>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script>
    // ---------- –ü–ï–†–°–ò–°–¢–ï–ù–¢–ù–û–°–¢–¨ ----------
    var SAVE_URL = null;            // –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: URL –≤–∞—à–µ–≥–æ API
    var AUTOSAVE_MS = 600;          // –¥–µ–±–∞—É–Ω—Å
    var _saveTimer = null;

    // ---------- –ö–ê–†–¢–ê ----------
    var map = L.map('map').setView([53.902284, 27.561831], 12);
    var osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '¬© OpenStreetMap' });
    var openTopo = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', { maxZoom: 17, attribution: '¬© OpenTopoMap | ¬© OSM' });
    var emptyBase = L.layerGroup();
    openTopo.addTo(map);
    L.control.layers({ '–ü—É—Å—Ç–∞—è (–±–µ–∑ –∑–¥–∞–Ω–∏–π)': emptyBase, 'OSM': osm, '–õ–∞–Ω–¥—à–∞—Ñ—Ç': openTopo }, {}, { position: 'topright' }).addTo(map);
    map.on('baselayerchange', function(e){
      if (e.name.indexOf('–ü—É—Å—Ç–∞—è') === 0) {
        map.eachLayer(function(l){ if (l instanceof L.TileLayer) { map.removeLayer(l); } });
        if (!map.hasLayer(emptyBase)) { emptyBase.addTo(map); }
      }
    });

    // ---------- –¢–ò–ü–´ –ó–û–ù ----------
    var TYPES = {
      bear: { emoji: 'üêª', fill: '#8B4513', stroke: '#5E2F0D' },
      wolf: { emoji: 'üê∫', fill: '#708090', stroke: '#4A5560' },
      fox:  { emoji: 'ü¶ä', fill: '#FF8C00', stroke: '#B35F00' }
    };
    var currentType = 'bear';
    Array.prototype.forEach.call(document.querySelectorAll('input[name="zoneType"]'), function(r){
      r.addEventListener('change', function(){ currentType = r.value; });
    });
    function styleFor(typeKey){ var t = TYPES[typeKey]; return { color: t.stroke, weight: 2, fillColor: t.fill, fillOpacity: 0.3 }; }

    // ---------- –°–õ–û–ò ----------
    var drawnItems = new L.FeatureGroup(); map.addLayer(drawnItems);
    var houses = new L.FeatureGroup();     map.addLayer(houses);

    // ---------- –†–ï–ñ–ò–ú–´ ----------
    var drawHandler = null;
    var houseMode = false;
    var editMode = false;
    var deleteMode = false;

    document.getElementById('btn-draw').addEventListener('click', function(){
      if (houseMode) { toggleHouseMode(false); }
      if (deleteMode) { toggleDeleteMode(false); }
      if (drawHandler) { drawHandler.disable(); }
      drawHandler = new L.Draw.Polygon(map, { allowIntersection: false, showArea: false, shapeOptions: styleFor(currentType) });
      drawHandler.enable();
    });
    document.getElementById('btn-edit').addEventListener('click', function(){
      editMode = true;
      drawnItems.eachLayer(function(layer){ if (layer instanceof L.Polygon && layer.editing && !layer.editing.enabled()) { layer.editing.enable(); } });
      houses.eachLayer(function(m){ if (m.dragging) { m.dragging.enable(); } });
    });
    document.getElementById('btn-finish-edit').addEventListener('click', function(){
      editMode = false;
      drawnItems.eachLayer(function(layer){ if (layer instanceof L.Polygon && layer.editing && layer.editing.enabled()) { layer.editing.disable(); } });
      houses.eachLayer(function(m){ if (m.dragging) { m.dragging.disable(); } });
      scheduleSave();
    });
    document.getElementById('btn-house').addEventListener('click', function(){ toggleHouseMode(); });
    document.getElementById('btn-delete').addEventListener('click', function(){ toggleDeleteMode(); });

    function toggleHouseMode(force){
      houseMode = (typeof force === 'boolean') ? force : !houseMode;
      if (houseMode && deleteMode) { toggleDeleteMode(false); }
      document.getElementById('btn-house').textContent = houseMode ? '–†–µ–∂–∏–º –¥–æ–º–∏–∫–æ–≤: –í–ö–õ' : '–†–µ–∂–∏–º –¥–æ–º–∏–∫–æ–≤';
      map.getContainer().style.cursor = houseMode ? 'crosshair' : '';
      if (houseMode && drawHandler) { drawHandler.disable(); }
    }
    function toggleDeleteMode(force){
      deleteMode = (typeof force === 'boolean') ? force : !deleteMode;
      if (deleteMode && houseMode) { toggleHouseMode(false); }
      if (deleteMode && drawHandler) { drawHandler.disable(); }
      document.getElementById('btn-delete').textContent = deleteMode ? '–£–¥–∞–ª–µ–Ω–∏–µ: –í–ö–õ' : '–£–¥–∞–ª–µ–Ω–∏–µ';
      map.getContainer().style.cursor = deleteMode ? 'not-allowed' : '';
    }

    // ---------- –†–ò–°–û–í–ê–ù–ò–ï –ü–û–õ–ò–ì–û–ù–ê ----------
    map.on(L.Draw.Event.CREATED, function(e){
      var layer = e.layer; // Polygon
      var t = TYPES[currentType];
      layer.setStyle(styleFor(currentType));
      layer.addTo(drawnItems);

      var outer = layer.getLatLngs()[0];
      var center = polygonCentroid(outer);
      var emoji = L.marker(center, { icon: L.divIcon({ className: 'emoji-icon', html: '<div style="font-size:24px;line-height:1">' + t.emoji + '</div>', iconSize: [24,24], iconAnchor: [12,12] }) });
      emoji.addTo(drawnItems);
      layer._emoji = emoji;
      layer._typeKey = currentType;

      layer.on('edit', function(){ var c = polygonCentroid(layer.getLatLngs()[0]); layer._emoji.setLatLng(c); scheduleSave(); });
      layer.on('contextmenu', function(){ removePolygon(layer); });
      layer.on('click', function(){ if (deleteMode) { removePolygon(layer); } });
      emoji.on('contextmenu', function(){ var poly = findPolygonByEmoji(emoji); if (poly) { removePolygon(poly); } });
      emoji.on('click', function(){ if (deleteMode) { var poly = findPolygonByEmoji(emoji); if (poly) { removePolygon(poly); } } });

      scheduleSave();
    });

    // ---------- –î–û–ú–ò–ö–ò ----------
    map.on('click', function(e){
      if (!houseMode) { return; }
      if (deleteMode) { return; }
      placeHouse(e.latlng);
    });
    function placeHouse(latlng){
      var icon = L.divIcon({ className: 'house-icon', html: '<div style="font-size:22px;line-height:1">üè†</div>', iconSize: [22,22], iconAnchor: [11,11] });
      var marker = L.marker(latlng, { icon: icon, draggable: true, autoPan: true });
      if (!editMode && marker.dragging) { marker.dragging.disable(); }
      marker.on('dragend', function(){ scheduleSave(); });
      marker.on('contextmenu', function(){ houses.removeLayer(marker); scheduleSave(); });
      marker.on('click', function(){ if (deleteMode) { houses.removeLayer(marker); scheduleSave(); } });
      houses.addLayer(marker);
      scheduleSave();
    }

    // ---------- –£–¢–ò–õ–ò–¢–´ ----------
    function removePolygon(layer){
      if (layer._emoji && drawnItems.hasLayer(layer._emoji)) { drawnItems.removeLayer(layer._emoji); }
      if (drawnItems.hasLayer(layer)) { drawnItems.removeLayer(layer); }
      scheduleSave();
    }
    function findPolygonByEmoji(marker){
      var found = null;
      drawnItems.eachLayer(function(l){ if (l instanceof L.Polygon && l._emoji === marker) { found = l; } });
      return found;
    }
    function polygonCentroid(latLngs){
      var ring = latLngs.map(function(p){ return [p.lat, p.lng]; });
      var area = 0, cx = 0, cy = 0;
      for (var i = 0, j = ring.length - 1; i < ring.length; j = i++){
        var y1 = ring[j][0], x1 = ring[j][1];
        var y2 = ring[i][0], x2 = ring[i][1];
        var f = (x1 * y2 - x2 * y1);
        area += f; cx += (x1 + x2) * f; cy += (y1 + y2) * f;
      }
      area = area * 0.5;
      if (Math.abs(area) < 1e-12){
        var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (var k = 0; k < ring.length; k++){
          var y = ring[k][0], x = ring[k][1];
          if (x < minX) { minX = x; } if (x > maxX) { maxX = x; }
          if (y < minY) { minY = y; } if (y > maxY) { maxY = y; }
        }
        return L.latLng((minY + maxY) / 2, (minX + maxX) / 2);
      }
      cx = cx / (6 * area); cy = cy / (6 * area);
      return L.latLng(cy, cx);
    }

    // ---------- SAVE/LOAD ----------
    (function initLoad(){ loadState().then(function(s){ if (s) { applyState(s); } }); })();
    function serializeState(){
      var polygons = [];
      drawnItems.eachLayer(function(layer){
        if (layer instanceof L.Polygon){
          var outer = layer.getLatLngs()[0] || [];
          var coords = outer.map(function(p){ return [p.lat, p.lng]; });
          polygons.push({ type: (layer._typeKey || 'bear'), coords: coords });
        }
      });
      var housesArr = [];
      houses.eachLayer(function(m){ var ll = m.getLatLng ? m.getLatLng() : null; if (ll){ housesArr.push({ lat: ll.lat, lng: ll.lng }); } });
      return { polygons: polygons, houses: housesArr };
    }
    function applyState(state){
      try{
        var toRemove = [];
        drawnItems.eachLayer(function(l){ toRemove.push(l); });
        for (var i=0;i<toRemove.length;i++){ drawnItems.removeLayer(toRemove[i]); }
        toRemove = [];
        houses.eachLayer(function(l){ toRemove.push(l); });
        for (var j=0;j<toRemove.length;j++){ houses.removeLayer(toRemove[j]); }
        var ps = state.polygons || [];
        for (var k=0;k<ps.length;k++){
          var p = ps[k];
          var latlngs = (p.coords||[]).map(function(c){ return L.latLng(c[0], c[1]); });
          if (latlngs.length < 3) { continue; }
          var layer = L.polygon(latlngs, styleFor(p.type||'bear'));
          layer._typeKey = p.type||'bear';
          layer.addTo(drawnItems);
          var t = TYPES[layer._typeKey];
          var center = polygonCentroid(layer.getLatLngs()[0]);
          var emoji = L.marker(center, { icon: L.divIcon({ className:'emoji-icon', html: '<div style="font-size:24px;line-height:1">'+t.emoji+'</div>', iconSize:[24,24], iconAnchor:[12,12] }) });
          emoji.addTo(drawnItems);
          layer._emoji = emoji;
          layer.on('edit', function(){ var c = polygonCentroid(this.getLatLngs()[0]); if (this._emoji) { this._emoji.setLatLng(c); } scheduleSave(); });
          layer.on('contextmenu', function(){ removePolygon(this); });
          layer.on('click', function(){ if (deleteMode) { removePolygon(this); } });
          (function(em){ em.on('contextmenu', function(){ var poly = findPolygonByEmoji(em); if (poly){ removePolygon(poly); } }); em.on('click', function(){ if (deleteMode){ var poly2 = findPolygonByEmoji(em); if (poly2){ removePolygon(poly2); } } }); })(emoji);
        }
        var hs = state.houses || [];
        for (var h=0; h<hs.length; h++){ placeHouse(L.latLng(hs[h].lat, hs[h].lng)); }
      } catch(err){ console.error('applyState error', err); }
    }
    function scheduleSave(){ if (_saveTimer){ clearTimeout(_saveTimer); } _saveTimer = setTimeout(saveState, AUTOSAVE_MS); }
    function saveState(){
      var data = serializeState();
      try { localStorage.setItem('map_state', JSON.stringify(data)); } catch(e){}
      if (SAVE_URL){ fetch(SAVE_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(data) }).catch(function(e){ console.warn('remote save failed', e); }); }
    }
    function loadState(){
      if (SAVE_URL){ return fetch(SAVE_URL).then(function(r){ if (!r.ok) { throw new Error('bad'); } return r.json(); }).catch(function(){ return loadStateLocal(); }); }
      return loadStateLocal();
    }
    function loadStateLocal(){ try { var raw = localStorage.getItem('map_state'); return Promise.resolve(raw ? JSON.parse(raw) : null); } catch(e){ return Promise.resolve(null); } }
  </script>
</body>
</html>
